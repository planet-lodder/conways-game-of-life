<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="Access-Control-Allow-Origin" content="*" />
    <title>Conway's Game of Life</title>
    <!-- Load HTMX, Alpine and Tailwind from a CDN -->
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/htmx/1.9.4/htmx.min.js"
      integrity="sha512-ZM2vxgVBxhBI5Etj/c/qcJV+upate3VzbVQOQRCx1YGuyEX9dYdMh8pRUot4xIwtAay6QwRQC/FdXRjSWIEHrg=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script
      src="https://cdnjs.cloudflare.com/ajax/libs/alpinejs/2.3.0/alpine.js"
      integrity="sha512-nIwdJlD5/vHj23CbO2iHCXtsqzdTTx3e3uAmpTm4x2Y8xCIFyWu4cSIV8GaGe2UNVq86/1h9EgUZy7tn243qdA=="
      crossorigin="anonymous"
      referrerpolicy="no-referrer"
    ></script>
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <script>
      htmx.config.useTemplateFragments = true;
    </script>
  </head>
  <body
    x-init="engine.load(preset, '.game-board');"
    x-data="{ preset: 'advanced', width: 8, height: 8, delay: 100, scale: 10, started: false }"
  >
    <!-- Main template -->
    <div
      class="flex flex-col min-h-screen w-full bg-gray-100 text-gray-700 dark:bg-gray-800 dark:text-gray-400"
    >
      <!-- App Toolbar -->
      <header
        class="flex w-full p-2 items-center justify-between border-b-2 bg-white border-gray-200 dark:bg-gray-800 dark:border-gray-700"
      >
        {% include 'toolbar.html' %}
      </header>

      <div class="flex flex-grow flex-row">
        <!-- Side Navigation -->
        <sidenav
          class="w-80 flex flex-col flex-0 overflow-y-auto border-gray-200 bg-white dark:bg-gray-600"
        >
          {% block sidenav %}{% include 'sidenav.html' %}{% endblock sidenav %}
        </sidenav>

        <!-- Main content page -->
        <main class="flex flex-col flex-1 overflow-y-auto">
          {% block content %}
          <div class="flex flex-col min-h-full justify-center">
            {% include 'board.html' %}
          </div>
          {% endblock content %}
        </main>

        <!-- Side panel (right) -->
        <aside
          id="aside"
          class="flex flex-col space-y-2 min-w-0 border-gray-200 bg-white dark:bg-gray-600"
        >
          {% block aside %}{% endblock aside %}
        </aside>
      </div>
    </div>

    <!-- Script block for initialisation hooks -->
    <script>
      tailwind.config = {
        darkMode: "class",
      };

      var get = (id) => document.getElementById(id);
      var stored = (k) => localStorage.getItem(k);
      var stores = (k, v) => localStorage.setItem(k, v);
      var target = document.body;
      var themeToggleDarkIcon = get("theme-toggle-dark-icon");
      var themeToggleLightIcon = get("theme-toggle-light-icon");

      // Change the icons inside the button based on previous settings
      var hasLocal = "color-theme" in localStorage;
      var localValue = hasLocal && stored("color-theme");
      var mediaDark = "(prefers-color-scheme: dark)";
      var isDark =
        (hasLocal && localValue === "dark") ||
        (!hasLocal && window.matchMedia(mediaDark).matches);
      if (isDark) {
        themeToggleLightIcon.classList.remove("hidden");
        target.classList.add("dark");
      } else {
        themeToggleDarkIcon.classList.remove("hidden");
        target.classList.remove("dark");
      }

      var themeToggleBtn = get("theme-toggle");
      themeToggleBtn.addEventListener("click", function () {
        // toggle icons inside button
        themeToggleDarkIcon.classList.toggle("hidden");
        themeToggleLightIcon.classList.toggle("hidden");

        // if set via local storage previously
        var value = stored("color-theme");
        if (value == "light" || !target.classList.contains("dark")) {
          target.classList.add("dark");
          stores("color-theme", "dark");
        } else {
          target.classList.remove("dark");
          stores("color-theme", "light");
        }
      });
    </script>
    <script>
      let engine = {
        preset: "",
        target: ".game-board",
        fpsSelector: "#fps-counter",
        scale: 5,
        width: 8,
        height: 8,
        data: [],
        delay: 0,
        generation: 0,
        intv: null,
        load: function (preset_name, target) {
          // Find the target element to use as the board canvas
          engine.preset = preset_name;
          engine.target = target || engine.target;
          board = document.querySelector(engine.target);
          data = [];

          // Load the preset (if exists)
          console.log("Loading preset:", preset_name);
          let preset = presets[preset_name];
          if (!preset) throw new Error("Preset not found!");
          if (preset.data) {
            // Raw data
            data = engine.loadRaw(preset);
          } else if (preset.text) {
            // Textual representation
            data = engine.loadText(preset.text);
          } else if (preset.image) {
            // Image supplied
            data = engine.loadImage(preset.image, (data) => engine.init(data));
            return; // Wait for image to load...
          }

          console.log(
            `Preset '${preset_name}' loaded: ${engine.width} x ${engine.height}`
          );
          engine.init(data);
        },
        loadRaw: function (data) {
          // Load the raw data and make a deep copy
          engine.width = data.length;
          engine.height = data[0].length;
          engine.data = JSON.parse(JSON.stringify(data));
        },
        loadText: function (input) {
          // Load the data from textual representation
          lines = input.split("\n");
          height = lines.length;
          width = 0;
          data = [];
          for (let y = 0; y < lines.length; y++) {
            let line = lines[y];
            for (let x = 0; x < line.length; x++) {
              val = [" ", ".", "0"].indexOf(line[x]) >= 0 ? 0 : 1;
              data[x] = data[x] || Array(lines.length);
              data[x][y] = val;
            }
            width = Math.max(width, line.length);
          }
          engine.width = width;
          engine.height = height;
          engine.data = data;
        },
        loadImage: function (src, callback) {
          let onLoad = (evt, target) => {
            const img = target;
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.width = img.width;
            canvas.height = img.height;
            ctx.drawImage(img, 0, 0);

            let data = Array(canvas.width);
            let buffer = ctx.getImageData(
              0,
              0,
              canvas.width,
              canvas.height
            ).data;
            console.log([canvas.width, canvas.height]);
            for (let x = 0; x < canvas.width; x++) {
              for (let y = 0; y < canvas.height; y++) {
                let i = (x + y * canvas.width) * 4;
                let r = buffer[i];
                let g = buffer[i + 1];
                let b = buffer[i + 2];
                let a = buffer[i + 3];
                let val = a < 64 || (r + g + b) / 3 > 192 ? 0 : 1;
                data[x] = data[x] || Array(canvas.height);
                data[x][y] = val;
              }
            }
            if (callback) callback(data);
          };
          img = document.createElement("IMG");
          img.src = src;
          img.style.position = "static";
          img.style.bottom = "0";
          img.style.right = "0";
          img.addEventListener("load", (e) => onLoad(e, img));
          document.body.appendChild(img);
        },
        init: function (data) {
          engine.data = data;
          engine.width = data.length;
          engine.height = data[0].length;

          // Calculate the new dimentions
          w = engine.width;
          h = engine.height;
          ratio = Math.min(w / screen.width, h / screen.height);
          scale = engine.scale;
          board.innerHTML = ""; // Crear prev.
          board.style["min-width"] = `${w * scale}px`;
          board.style["min-height"] = `${h * scale}px`;

          // Create the canvas to visualise the data
          console.log("Creating game board...", [w, h]);
          canvas = Array(h);
          self.canvas = canvas;
          for (y = 0; y < h; y++) {
            // Create a new data colum
            canvas[y] = Array(w);

            // Create the element to put on the board
            rowElem = document.createElement("DIV");
            rowElem.className = "row";
            board.appendChild(rowElem);

            // Create each row and populate each row
            for (x = 0; x < w; x++) {
              // Compute the target cell's value
              col = data && data.length >= x ? data[x] : [];
              cell = col && col.length >= y ? col[y] : null;
              val = cell ? 1 : 0;

              // Create the cell at this x/y position on the board
              cellElem = document.createElement("DIV");
              cellElem.id = `${x}x${y}`;
              cellElem.setAttribute("value", val);
              cellElem.onclick = engine.handleClick(x, y, cellElem);
              cellElem.onmouseenter = engine.handleOnEnter(x, y, cellElem);
              rowElem.appendChild(cellElem);

              canvas[y][x] = cellElem;
            }
          }
        },
        start: function (delay) {
          console.log("Starting the game", delay);
          // Set the game defaults when starting
          engine.generation = 0;
          engine.delay = delay || engine.delay;

          // Start running game ticks
          engine.intv = setInterval(engine.tick, engine.delay);

          // Compute the fps each second
          oldCount = engine.generation;
          fpsElem = document.querySelector(engine.fpsSelector);
          fps_intv = setInterval(() => {
            if (!engine.intv) {
              clearInterval(fps_intv); // Simulation stopped
              return;
            }
            if (fpsElem) {
              // Update DOM element
              fpsElem.setAttribute("value", engine.generation - oldCount);
            }
            oldCount = engine.generation;
          }, 1000);
        },
        stop: function () {
          console.log("Stopping the game");
          clearInterval(engine.intv);
          engine.intv = null;
        },
        tick: function () {
          // Start new generation
          engine.generation++;

          const getValue = (x, y) => {
            if (x < 0 || x >= engine.width) return 0;
            if (y < 0 || y >= engine.height) return 0;
            return engine.data[x][y];
          };
          const newValue = (x, y) => {
            // Check each neighbor cell and count them
            count = 0; // Keep track of the count
            for (var dx = -1; dx <= 1; dx++) {
              for (var dy = -1; dy <= 1; dy++) {
                count += dx == 0 && dy == 0 ? 0 : getValue(x + dx, y + dy);
                if (count > 3) return 0; // Over-populated, cell dies, no need to continue
              }
            }
            val = getValue(x, y); // Get current value
            if (count == 3) return 1; // Cell is alive if count exactly 3
            if (count == 2 && val) return 1; // Cell stays alive if 2 neighbors
            return 0; // Cell is dead or not enough siblings
          };

          // Calculate for each cell its new value
          data = []; // New data frame
          for (x = 0; x < w; x++) {
            data[x] = Array(engine.width);
            for (y = 0; y < h; y++) {
              // Set new value for the cell
              val = newValue(x, y);
              data[x][y] = val;

              // Update DOM element
              canvas[y][x].setAttribute("value", val);
            }
          }
          engine.data = data;
        },
        paint: function (x, y, elem, val) {
          engine.data[x][y] = val;
          if (elem) {
            elem.setAttribute("value", val || 0);
          }
        },
        handleClick: function (x, y, elem, val) {
          return () => {
            val = elem.getAttribute("value") == "1" ? 0 : 1;
            engine.paint(x, y, elem, val);
          };
        },
        handleOnEnter: function (x, y, elem, val) {
          return (evt) => {
            if (evt.buttons === 1) {
              engine.paint(x, y, elem, 1);
            }
          };
        },
      };
    </script>
    <script>
      let presets = {
        // This sample gives raw data[x][y]
        simple: {
          title: "Simple examples",
          data: [
            [0, 0, 0, 0, 0, 0, 1, 1],
            [0, 0, 0, 0, 0, 0, 1, 1],
            [0, 0, 0, 0, 1, 1, 0, 0],
            [0, 0, 0, 0, 1, 1, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
            [0, 1, 1, 1, 0, 0, 0, 0],
            [0, 0, 0, 0, 0, 0, 0, 0],
          ],
        },
        // Stable shapes in textual representation
        stable: {
          title: "Text example",
          text: [
            "        ",
            "  11    ",
            " 1  1   ",
            "  11    ",
            "        ",
            "        ",
            "   11   ",
            "   11   ",
          ].join("\n"),
        },
        advanced: {
          title: "Advanced example",
          image:
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADIAAAAmCAYAAACGeMg8AAAAAXNSR0IArs4c6QAAARBJREFUWEftmG0PwyAIhOv//9EubWJC3Coc5awu9KsM74HzbaXWWo8/+MoskFLKwawZFeQUL78eJBLODaKJ0CBOQC0H4ngXSBMwEiLHrIIbvMeCMEgv6m5yS0f6ij8GQRJYQZp1RmsEsY4We3WEBSInt9pLE3w3DltLLlK2OATKBRK94yCCQztindiyu1lzaXHujmiJ2ziy/qw5f8VNAfGcCygUHQQV5I1PEG/lWL/LjkRUNvJAfb0jUdvzqyBRENdNY9ZTN8KKoxwJwq4wmj87glaMHb9sR9AnwLIg8s1vuT0vD2KByHOEvXA9+Ze2FgKUIEi1GLFf/3jufGmUt+dtrdU/AbYF6e2aIIwF/CTnB95iD57N0V/WAAAAAElFTkSuQmCC",
        },
        complex: {
          title: "A Complex example",
          image:
            "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAXsAAADABAMAAAAXat46AAAAD1BMVEX///8CAs/PAgICzwLmfhfNmKloAAADj0lEQVR4Ae3cQW7rOgyF4d/HWYCzgwOuIEA3kMHd/5oe4EFrlLkv7Y1ghQC/GduJYUgURcmhtdZaawUsV0pbKG2jmNbalcqWpXN+a6393HVLYSlbCitZqi0BrbVlS2El25bCzvmttfbDlnIO39xSu/Lcqi0BrbXr87BOSzmHnfNbe5FMZRFUFvKpLeUcviaGj6JtQuUpx4ycvzCGwlQWVCNRWlCa2dlEnNBSzuEIRlge31J+Ho5gjIhiOd9mJwTCVYu1KDaLwwAqmn8UQWEKmSOLUgKJI4N8Zks5hS8suMYjKs7lxMrTh+2WwiMqzu3cJUAAQuXyj3x4YtVsLyhAFq5ZiIZBkTddFTZe6e2/mISu48JfJk/x+hKwLMPC32eeA2tCzq/XZuvNb86ZxUp/pbjQxktowLb3XDafIoY0Ha7b+PDZDtcm+8eWzzY+fDbcbUZZzl8CXPqQSPkPdbK/bZz+VqbVb+fRo+MxURQaOvmlyz+uhpZtfPicIk9iOR6vataolvL4hrNy8sn/87ycnylS8L8VnTFvRaUPHUMO16304zAdxS5kqpBRHB8/12lmF2Sst/PDywUud/JkRJaQ8+zQk8dfrueEuz+HxxeADAFYxt9mtAIIswvz2HJWCNxTh83f3r7Q4/RkHtvmLgF57DudIcnYvB05ZR6RBhEGosAdtgAizM5UFYBLP77iq1KQc8X5cQOuJ4W/J38tDRFpMK2ssCznhL8WDn9NgJAxnpvzM/0tFAoILHaRKs4b3GaE/OGTDfEoNDaE+asP1tuM8HLhk430KLQAAos3c7nzSSA/Co1w6eQfqSidWTGPv5a6rnPCUdZJ4SAfk8J+97BymxCOmbsF3n6M7631ujWqavhY19uEcEDNNkH9innAfqWM57vF28eEcMBevUDiH98p6T5V/S7h5V66R3u/j+qQz9ks3gecT0x8/GGnQ2XP5vpktM+la98KqHsnY/yNmPHG30eqfxus7+L1Tcjy91Cj9C1giZ1NSRp5A36CAd8fFP/6o7+96S+fcsoMyomgJud9okUVIYQhOHKRFTjCCMGA740nsMDI9b72lvPbL9R1kNPYr0QgHzNPgDB1+PvPfIAoxMeOpwOhsh+ly4VWX4VMXYoACIoKAxIHUXXXi0wYUZIMioCgpDCS6/7OEMQeUI3NrlzNkA8QTZtHmNJEYUIUpHDlfo8xpZnCLN5Ma6211v4DPI1wVwR7xR8AAAAASUVORK5CYII=",
        },
      };
    </script>
  </body>
</html>
